#!/usr/bin/env python3
# Advent of Code 2021
# Glenn G. Chappell

import sys          # .stdin
import re           # .search
import itertools    # .product, .combinations
import queue        # .SimpleQueue


# ======================================================================
# NOTES
# ======================================================================


# vec3 - 3-vector
# Represented as a 3-item list. Thought of as a column vector.

# mat3 - 3x3 matrix
# Represented as a list of three vec3 items -- its columns. In practice,
# a mat3 represents a rotation of 3-space: an orthogonal matrix with
# determanent 1.

# transform - rigid transformation of 3 space
# Represented as a list of four vec3 items. Items 0-2 are the columns of
# a mat3. Item 3 is a separate vec3. Calling the matrix "A" and the
# final vec3 "b", applying the transformation to a vec3 does Ax + b.


# ======================================================================
# HELPER FUNCTIONS
# ======================================================================


# good_mats
# All 3x3 matrices in mutiplicative group generated by 90-degree
# rotations about x, y, z axes.
good_mats = [
    [[ 1, 0, 0],[ 0, 1, 0],[ 0, 0, 1]],
    [[-1, 0, 0],[ 0,-1, 0],[ 0, 0, 1]],
    [[-1, 0, 0],[ 0, 1, 0],[ 0, 0,-1]],
    [[ 1, 0, 0],[ 0,-1, 0],[ 0, 0,-1]],

    [[-1, 0, 0],[ 0, 0, 1],[ 0, 1, 0]],
    [[ 1, 0, 0],[ 0, 0,-1],[ 0, 1, 0]],
    [[ 1, 0, 0],[ 0, 0, 1],[ 0,-1, 0]],
    [[-1, 0, 0],[ 0, 0,-1],[ 0,-1, 0]],

    [[ 0,-1, 0],[ 1, 0, 0],[ 0, 0, 1]],
    [[ 0, 1, 0],[-1, 0, 0],[ 0, 0, 1]],
    [[ 0, 1, 0],[ 1, 0, 0],[ 0, 0,-1]],
    [[ 0,-1, 0],[-1, 0, 0],[ 0, 0,-1]],

    [[ 0, 1, 0],[ 0, 0, 1],[ 1, 0, 0]],
    [[ 0,-1, 0],[ 0, 0,-1],[ 1, 0, 0]],
    [[ 0,-1, 0],[ 0, 0, 1],[-1, 0, 0]],
    [[ 0, 1, 0],[ 0, 0,-1],[-1, 0, 0]],

    [[ 0, 0, 1],[ 1, 0, 0],[ 0, 1, 0]],
    [[ 0, 0,-1],[-1, 0, 0],[ 0, 1, 0]],
    [[ 0, 0,-1],[ 1, 0, 0],[ 0,-1, 0]],
    [[ 0, 0, 1],[-1, 0, 0],[ 0,-1, 0]],

    [[ 0, 0,-1],[ 0, 1, 0],[ 1, 0, 0]],
    [[ 0, 0, 1],[ 0,-1, 0],[ 1, 0, 0]],
    [[ 0, 0, 1],[ 0, 1, 0],[-1, 0, 0]],
    [[ 0, 0,-1],[ 0,-1, 0],[-1, 0, 0]],
]


def det_mat3(m):
    """Find the determinant of the given matrix.
    This function is ONLY defined so we can test variable good_mats.

    >>> len(good_mats)
    24
    >>> all(( a != b for a, b in itertools.combinations(good_mats, 2) ))
    True
    >>> all(( det_mat3(mat) == 1 for mat in good_mats ))
    True

    """
    assert type(m) == list
    assert len(m) == 3
    assert all(( type(colvec) == list for colvec in m ))

    d0 = m[1][1]*m[2][2]-m[1][2]*m[2][1]
    d1 = m[1][0]*m[2][2]-m[1][2]*m[2][0]
    d2 = m[1][0]*m[2][1]-m[1][1]*m[2][0]
    return m[0][0]*d0 - m[0][1]*d1 + m[0][2]*d2


def add_vec3_vec3(va, vb):
    """Return the sum of given vec3 values.

    >>> va = [1,5,-2]
    >>> vb = [-10,4,6]
    >>> add_vec3_vec3(va, vb)
    [-9, 9, 4]

    """
    assert type(va) == list
    assert type(vb) == list

    vv = [ None for _ in range(3) ]
    for row in range(3):
        vv[row] = va[row] + vb[row]
    return vv


def sub_vec3_vec3(va, vb):
    """Return va - vb.

    >>> va = [1,5,-2]
    >>> vb = [-10,4,6]
    >>> sub_vec3_vec3(va, vb)
    [11, 1, -8]

    """
    assert type(va) == list
    assert type(vb) == list

    vv = [ None for _ in range(3) ]
    for row in range(3):
        vv[row] = va[row] - vb[row]
    return vv


def mult_mat3_vec3(m, v):
    """Multiply a mat3 by a vec3, returning the resulting vec3.

    >>> m = [[0,1,0],[0,0,-1],[-1,0,0]]
    >>> v = [2,-3,7]
    >>> mult_mat3_vec3(m, v)
    [-7, 2, 3]

    """
    assert type(m) == list
    assert len(m) == 3
    assert all(( type(colvec) == list for colvec in m ))
    assert type(v) == list

    vv = [ None for _ in range(3) ]
    for row in range(3):
        total = 0
        for i in range (3):
            total += m[i][row] * v[i]
        vv[row] = total
    return vv


def mult_mat3_mat3(ma, mb):
    """Return the product of two mat3 values.

    >>> ma = [[0,1,0],[0,0,-1],[-1,0,0]]
    >>> mb = [[-1,0,0],[0,0,1],[0,1,0]]
    >>> mult_mat3_mat3(ma, mb)
    [[0, -1, 0], [-1, 0, 0], [0, 0, -1]]
    >>> mm = mult_mat3_mat3(mb, ma)
    >>> v = [-7,-9,4]
    >>> vv1 = mult_mat3_vec3(ma, v)
    >>> vv2 = mult_mat3_vec3(mb, vv1)
    >>> vv3 = mult_mat3_vec3(mm, v)
    >>> vv2 == vv3
    True

    """
    assert type(ma) == list
    assert len(ma) == 3
    assert all(( type(colvec) == list for colvec in ma ))
    assert type(mb) == list
    assert len(mb) == 3
    assert all(( type(colvec) == list for colvec in mb ))

    mm = [ [ None for _ in range(3) ] for _ in range(3) ]
    for col in range(3):
        for row in range(3):
            total = 0
            for i in range(3):
                total += ma[i][row] * mb[col][i]
            mm[col][row] = total
    return mm


def transpose_mat3(m):
    """Return the transpose of a given mat3.

    >>> m = [[0,1,0],[0,0,-1],[-1,0,0]]
    >>> mt = transpose_mat3(m)
    >>> mt
    [[0, 0, -1], [1, 0, 0], [0, -1, 0]]
    >>> v = [-6,5,-11]
    >>> vv1 = mult_mat3_vec3(m, v)
    >>> vv2 = mult_mat3_vec3(mt, vv1)
    >>> vv2 == v
    True

    """
    assert type(m) == list
    assert len(m) == 3
    assert all(( type(colvec) == list for colvec in m ))

    mm = [ [ None for _ in range(3) ] for _ in range(3) ]
    for col in range(3):
        for row in range(3):
            mm[col][row] = m[row][col]
    return mm


def apply_transform_vec3(t, v):
    """Return the result of applying the transform to the vec3.

    >>> t = [[0,1,0],[0,0,-1],[-1,0,0],[6,-5,1]]
    >>> v = [2,-3,7]
    >>> apply_transform_vec3(t, v)
    [-1, -3, 4]

    """
    assert type(t) == list
    assert len(t) == 4
    assert all(( type(colvec) == list for colvec in t ))
    assert type(v) == list

    v1 = mult_mat3_vec3(t[0:3], v)
    vv = add_vec3_vec3(v1, t[3])
    return vv


def id_transform():
    """Returns the identity transform.

    >>> it = id_transform()
    >>> it
    [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
    >>> v = [4,-10,1]
    >>> apply_transform_vec3(it, v) == v
    True

    """
    return [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]


def inverse_transform(t):
    """Returns the transform that is the inverse of that given.

    >>> t = [[0,1,0],[0,0,-1],[-1,0,0],[6,-5,1]]
    >>> tinv = inverse_transform(t)
    >>> tinv
    [[0, 0, -1], [1, 0, 0], [0, -1, 0], [5, 1, 6]]
    >>> v = [7,-8,2]
    >>> vv1 = apply_transform_vec3(t, v)
    >>> vv2 = apply_transform_vec3(tinv, vv1)
    >>> vv2 == v
    True

    """
    assert type(t) == list
    assert len(t) == 4
    assert all(( type(colvec) == list for colvec in t ))

    minv = transpose_mat3(t[0:3])
    vv = mult_mat3_vec3(minv, t[3])
    for i in range(3):
        vv[i] = -vv[i]
    tt = minv + [vv]
    return tt


def compose_transform_transform(ta, tb):
    """Returns composition of ta, tb. (So tb is applied first.)

    >>> ta = [[0,1,0],[0,0,-1],[-1,0,0],[6,-5,1]]
    >>> tb = [[-1,0,0],[0,0,1],[0,1,0],[3,-8,2]]
    >>> compose_transform_transform(ta, tb)
    [[0, -1, 0], [-1, 0, 0], [0, 0, -1], [4, -2, 9]]
    >>> tt = compose_transform_transform(tb, ta)
    >>> v = [4,6,-10]
    >>> vv1 = apply_transform_vec3(ta, v)
    >>> vv2 = apply_transform_vec3(tb, vv1)
    >>> vv3 = apply_transform_vec3(tt, v)
    >>> vv2 == vv3
    True

    """
    assert type(ta) == list
    assert len(ta) == 4
    assert all(( type(colvec) == list for colvec in ta ))
    assert type(tb) == list
    assert len(tb) == 4
    assert all(( type(colvec) == list for colvec in tb ))

    ma = ta[0:3]
    mb = tb[0:3]
    mm = mult_mat3_mat3(ma, mb)
    vv1 = mult_mat3_vec3(ma, tb[3])
    vv = add_vec3_vec3(vv1, ta[3])
    tt = mm + [vv]
    return tt


def all_transforms_vec3_to_vec3(va, vb):
    """Generator. Yields all transforms taking vec3 va to vec3 vb.

    >>> va = [1,-7,-3]
    >>> vb = [14,0,-5]
    >>> tlist = list(all_transforms_vec3_to_vec3(va, vb))
    >>> all(( a != b for a, b in itertools.combinations(tlist, 2) ))
    True
    >>> all(( apply_transform_vec3(t, va) == vb for t in tlist ))
    True

    """
    assert type(va) == list
    assert type(vb) == list

    for m in good_mats:
        vv1 = mult_mat3_vec3(m, va)
        vv2 = sub_vec3_vec3(vb, vv1)
        tt = m + [vv2]
        yield tt


def match_with_transform(ptsa, ptsb, t):
    """Lists of pts, transform -> do they match & at how many pts.

    Two lists of points (point = vec3) are given, alont with a
    transform that might take the coordinate system of the former to
    that of the latter. Return value is False if there are
    inconsistencies. Otherwise, return value is the number of points
    that the two lists have in common when coordinates are transformed.

    >>> pp1 = [[0,0,0],[1,0,0],[0,0,2],[0,0,3],[0,0,999]]
    >>> pp2 = [[1,1,1],[1,1,0],[3,1,1],[4,1,1]]
    >>> t1 = [[1,0,0],[0,1,0],[0,0,1],[1,1,1]]
    >>> match_with_transform(pp1,pp2,t1)
    False
    >>> t2 = [[0,0,-1],[0,1,0],[1,0,0],[1,1,1]]
    >>> match_with_transform(pp1,pp2,t2)
    4

    """
    assert type(ptsa) == list
    assert type(ptsb) == list
    assert type(t) == list
    assert len(t) == 4
    assert all(( type(colvec) == list for colvec in t ))

    count1 = 0
    for v in ptsa:
        assert type(v) == list
        assert all(( abs(c) < 1000 for c in v ))
        vv = apply_transform_vec3(t, v)
        assert type(vv) == list
        if any(( abs(c) >= 1000 for c in vv )):
            continue
        if vv not in ptsb:
            return False
        else:
            count1 += 1

    tinv = inverse_transform(t)
    count2 = 0
    for v in ptsb:
        assert type(v) == list
        assert all(( abs(c) < 1000 for c in v ))
        vv = apply_transform_vec3(tinv, v)
        assert type(vv) == list
        if any(( abs(c) >= 1000 for c in vv )):
            continue
        if vv not in ptsa:
            return False
        else:
            count2 += 1

    assert count1 == count2
    return count1


def match(ptsa, ptsb):
    """Lists of pts -> do they match up at >= 12 pts & transform if so.

    Returns False or transform.

    >>> pp1 = [[0,0,0],[1,0,0]] + [ [0,0,i] for i in range(2,12) ]
    >>> pp2 = [[1,1,1],[1,1,0]] + [ [i+1,1,1] for i in range(2,12) ]
    >>> match(pp1, pp2)
    [[0, 0, -1], [0, 1, 0], [1, 0, 0], [1, 1, 1]]
    >>> match(pp1 + [[0,0,999]], pp2)
    [[0, 0, -1], [0, 1, 0], [1, 0, 0], [1, 1, 1]]
    >>> match(pp1, pp2 + [[-999,0,0]])
    [[0, 0, -1], [0, 1, 0], [1, 0, 0], [1, 1, 1]]
    >>> pp3 = [[0,0,0],[1,0,0]] + [ [0,0,i] for i in range(2,11) ]
    >>> pp4 = [[1,1,1],[1,1,0]] + [ [i+1,1,1] for i in range(2,11) ]
    >>> match(pp3, pp4)
    False

    """
    assert type(ptsa) == list
    assert type(ptsb) == list

    for va, vb in itertools.product(ptsa, ptsb):
        for t in all_transforms_vec3_to_vec3(va, vb):
            assert apply_transform_vec3(t, va) == vb
            rr = match_with_transform(ptsa, ptsb, t)
            if rr is False or rr < 12:
                continue
            return t
    return False


# ======================================================================
# MAIN PROGRAM
# ======================================================================


def main():
    # *** Process Input ***

    dataset = []
    scanner_num = 0
    scanner_data = []
    for line in sys.stdin:
        line = line.rstrip()
        if line == "":
            assert scanner_num == len(dataset)
            assert scanner_data != []
            dataset.append(scanner_data[:])
            scanner_num += 1
            scanner_data = []
        elif line[0:2] == "--":
            mo = re.search(r"^--- scanner (\d+) ---$", line)
            assert mo
            sn = int(mo[1])
            assert sn == scanner_num
        else:
            mo = re.search(r"^(-?\d{1,3}),(-?\d{1,3}),(-?\d{1,3})$",
                           line)
            assert mo
            scanner_data.append([int(mo[1]), int(mo[2]), int(mo[3])])
    # Not quite DRY <sigh>
    assert scanner_data != []
    assert scanner_num == len(dataset)
    dataset.append(scanner_data)

    # *** Do Computation ***

    # Map scanner ix to transform taking its pts to space of scanner 0
    start_scanner = 0
    scanner_map = { start_scanner:id_transform() }
    q = queue.SimpleQueue()
    q.put(start_scanner)
    print(f"Scanners linked: {len(scanner_map)}/{len(dataset)}")
    while not q.empty():
        sc1 = q.get()
        assert sc1 in scanner_map
        for sc2 in range(len(dataset)):
            if sc2 in scanner_map:
                continue

            t = match(dataset[sc2], dataset[sc1])
            if t is False:
                continue
            tt = compose_transform_transform(scanner_map[sc1], t)
            scanner_map[sc2] = tt
            print(f"Scanners linked: {len(scanner_map)}/{len(dataset)}")
            q.put(sc2)

    # We assume graph of scanners is connected
    assert len(scanner_map) == len(dataset)

    # Make set of all points (as tuples)
    all_pts = set()
    for sc in range(len(dataset)):
        t = scanner_map[sc]
        assert type(t) == list
        assert len(t) == 4
        assert all(( type(colvec) == list for colvec in t ))
        for v in dataset[sc]:
            assert type(v) == list
            vv = apply_transform_vec3(t, v)
            assert type(vv) == list
            all_pts.add(tuple(vv))

    result = len(all_pts)

    # *** Print Answer ***

    #print("-" * 60)
    print(f"Answer: {result}")


if __name__ == "__main__":
    main()

